# docker

run: `docker-compose up`

stop: `docker-compose down`

## docker 镜像原理
Docker 镜像

我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。

Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

分层存储

因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。

镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。


### 构建前端镜像

首先按照Docker文档在根目录下新建并编写Dockerfile，其中规定使用环境为Node:10，这样就不会自动拉取最新版本的node导致错误；并且规定启动docker运行时执行npm install安装依赖，这里要注意不能在构建镜像的文件夹下包含node_modules，这样会让镜像变得很大，只需要在构建时下载即可；最后构建完毕后运行时执行npm run serve，规定把前端部分运行在8081端口。

在目录下执行命令`sudo docker build -t goswapifront .`构建镜像，指定镜像名称为goswapifront，构建成功后可以在docker的镜像列表中看到该镜像，最后用`docker run -d -p 8081:8081 goswapifront`在后台运行镜像，其中指定主机的8081端口映射到容器的8081端口，这样就成功启动了镜像。

在整个项目中为了运行docker-compose，需要编写compose的约束文件，指定前端镜像的文件夹，只要改文件夹下包含dockerfile，这一部分就可以正确运行了。

## Dockerfile 指令简介
1. FROM 构建自定义镜像的基础镜像
2. RUN  构建镜像过程中执行的命令， 每一个RUN 相当于新建一层存储
3. COPY 复制系统文件到容器的特定目录
4. CMD   运行容器时会执行的命令。  和RUN 的相同：都是执行命令。 不同：RUN 是用于构建镜像 CMD 是镜像变为容器时会运行的命令
5. ENTRYPOINT  和cMD功能一样， 不过有了ENTRYPOINT CMD 的指令会变成ENTRYPOINT的参数
6. ENV    设置环境变量， 就和windows 下设置java环境变量一样，可以在系统环境引用
7. WORKDIR  设置工作目录，即在控制台中 cd 指令一样
8. VOLUME    设置挂载卷，容器结束运行后，对挂载卷的内容会保存在宿主系统里面，而不是随着容器的结束，存储被销毁
